import express from "express";
import fetch from "node-fetch";
import { create } from "xmlbuilder2";
import { XMLParser } from "fast-xml-parser";

// fast-xml-parser v4 exports XMLParser class. Instantiate once with
// options (keep attributeNamePrefix to "@_" so existing code that
// references "@_href" continues to work).
const parser = new XMLParser({ ignoreAttributes: false, attributeNamePrefix: "@_" });

const app = express();
const cache = new Map();
const CACHE_DURATION = 60 * 60 * 1000;

// --- è¾…åŠ©å‡½æ•°ï¼šæ ¹æ® YouTube é¢‘é“ XML æ•°æ®ç”Ÿæˆ RSS 2.0 æ ¼å¼ ---
function generateRssFromFeed(feed, channelId, title, description = "Generated by Node.js YouTube RSS Proxy") {
  const rss = create({ version: "1.0", encoding: "UTF-8" })
    .ele("rss", {
      version: "2.0",
      "xmlns:media": "http://search.yahoo.com/mrss/"
    })
    .ele("channel")
    .ele("title").txt(title).up()
    .ele("link").txt(`https://www.youtube.com/channel/${channelId}`).up()
    .ele("description").txt(description).up();

  // ç¡®ä¿ feed.entry æ˜¯æ•°ç»„ï¼Œå³ä½¿åªæœ‰ä¸€ä¸ª item
  const entries = Array.isArray(feed.entry) ? feed.entry : (feed.entry ? [feed.entry] : []);
  entries.forEach((video) => {
    const videoId = video["yt:videoId"];
    const item = rss.ele("item");
    item.ele("title").txt(video.title).up();
    // ä½¿ç”¨ video.link["@_href"] ä½œä¸ºé“¾æ¥
    item.ele("link").txt(video.link["@_href"]).up();
    item.ele("guid").txt(videoId).up();
    item.ele("pubDate").txt(new Date(video.published).toUTCString()).up();
    item.ele("description").dat(video["media:group"]["media:description"]).up();
    // Add thumbnail if available
    const thumbnail = video["media:group"]["media:thumbnail"];
    if (thumbnail && thumbnail["@_url"]) {
      item.ele("media:thumbnail", { url: thumbnail["@_url"] }).up();
    }
    item.up();
  });

  return rss.end({ prettyPrint: true });
}

// --- è¾…åŠ©å‡½æ•°ï¼šè·å–å¹¶è§£æ YouTube XML è®¢é˜…æº ---
async function fetchAndParseFeed(feedUrl) {
  const response = await fetch(feedUrl);
  if (!response.ok) throw new Error(`Fetch failed with status: ${response.status} for URL: ${feedUrl}`);

  const text = await response.text();
  const parsed = parser.parse(text);
  return parsed.feed;
}


app.get("/", (req, res) => {
  res.send("âœ… YouTube RSS Proxy is running. Use /api/rss?channel_id=... or /api/user/@username");
});

// --- ç°æœ‰è·¯ç”±ï¼šé€šè¿‡ channel_id è·å– RSS ---
app.get("/api/rss", async (req, res) => {
  const channelId = req.query.channel_id;
  if (!channelId) return res.status(400).send("âŒ Missing channel_id parameter");

  const cacheKey = `channel:${channelId}`;
  const cached = cache.get(cacheKey);
  const now = Date.now();
  if (cached && now - cached.timestamp < CACHE_DURATION) {
    res.type("application/xml").send(cached.data);
    return;
  }

  try {
    const feedUrl = `https://www.youtube.com/feeds/videos.xml?channel_id=${channelId}`;
    const feed = await fetchAndParseFeed(feedUrl);
    
    // ä½¿ç”¨è¾…åŠ©å‡½æ•°ç”Ÿæˆ RSS
    const xmlOutput = generateRssFromFeed(feed, channelId, feed.title);
    
    cache.set(cacheKey, { data: xmlOutput, timestamp: now });
    res.type("application/xml").send(xmlOutput);

  } catch (err) {
    console.error("âŒ Fetch or parse error:", err);
    res.status(500).send("âŒ Failed to fetch or parse feed");
  }
});


// --- æ–°å¢è·¯ç”±ï¼šé€šè¿‡ç”¨æˆ·å¥æŸ„ (username) è·å– RSS ---
// æ³¨æ„ï¼šåŸä»£ç ä¸­çš„ /user/:username/:routeParams? ç»“æ„åœ¨ Express ä¸­é€šå¸¸ç®€åŒ–ä¸º /user/:username
// æˆ‘ä»¬é€šè¿‡ req.query æ¥æ¥æ”¶å‚æ•°ï¼Œè€Œä¸æ˜¯ /:routeParams?
app.get("/api/user/:username", async (req, res) => {
  const username = req.params.username;
  if (!username) return res.status(400).send("âŒ Missing username parameter");

  // --- å‚æ•°è§£æé€»è¾‘ (æ ¹æ®ç¬¬ä¸€ä¸ªä»£ç å—) ---
  // Express ä½¿ç”¨ req.query è·å–æŸ¥è¯¢å­—ç¬¦ä¸²å‚æ•°ï¼Œå¦‚ ?embed=1&filterShorts=false
  
  // åŸä»£ç çš„ `embed` é€»è¾‘: const embed = !params.get('embed');
  // å¦‚æœ URL ä¸­æœ‰ `embed` å‚æ•°ï¼ˆå¦‚ ?embed=1ï¼‰ï¼Œåˆ™ embed ä¸º false (ä¸åµŒå…¥)ã€‚
  // å¦‚æœ URL ä¸­æ²¡æœ‰ `embed` å‚æ•°ï¼Œåˆ™ embed ä¸º true (åµŒå…¥)ã€‚
  // åœ¨ RSS ä»£ç†ä¸­ï¼Œé€šå¸¸ä¸éœ€è¦è¿™ä¸ªå‚æ•°ï¼Œä½†æˆ‘ä»¬è§£æå®ƒã€‚
  const embed = !req.query.embed; 

  // åŸä»£ç çš„ `filterShorts` é€»è¾‘:
  // const filterShorts = filterShortsStr === null || filterShortsStr === '' || filterShortsStr === 'true';
  // ä»…åœ¨ filterShorts ä¸º 'false' æˆ–å…¶ä»– falsy å€¼æ—¶ï¼Œæ‰ä¸è¿‡æ»¤ Shortsã€‚é»˜è®¤è¿‡æ»¤ã€‚
  const filterShortsStr = req.query.filterShorts;
  const filterShorts = filterShortsStr === undefined || filterShortsStr === '' || filterShortsStr === 'true';
  
  // æ³¨æ„ï¼šåŸä»£ç çš„ handler å‡½æ•°ä½¿ç”¨äº† getDataByUsernameYoutubei å’Œ getDataByUsernameGoogleï¼Œ
  // å®ƒä»¬æ˜¯è°ƒç”¨ API è·å–æ•°æ®çš„æŠ½è±¡ã€‚åœ¨è¿™ä¸ª Express ä»£ç†ä¸­ï¼Œæˆ‘ä»¬**æ— æ³•ç›´æ¥è®¿é—®**è¿™äº›å†…éƒ¨ APIã€‚
  // **è§£å†³æ–¹æ¡ˆï¼š** // 1. **æœ€ç›´æ¥çš„æ¨¡ä»¿ (ä¸å‡†ç¡®):** å°è¯•ç”¨ `username` ç›´æ¥æ„é€ ä¸€ä¸ª YouTube XML è®¢é˜…æº URLã€‚
  //    é—æ†¾çš„æ˜¯ï¼ŒYouTube çš„ /feeds/videos.xml **åªæ”¯æŒ `channel_id` æˆ– `user` (legacy)ã€‚**
  //    **ä¸ç›´æ¥æ”¯æŒ** `username` (ç”¨æˆ·å¥æŸ„ï¼Œå¦‚ @JFlaMusic)ã€‚
  // 2. **éœ€è¦é¢å¤–çš„ API æ­¥éª¤ (æ›´å‡†ç¡®):** å¿…é¡»å…ˆé€šè¿‡ YouTube Data API (v3) æˆ–è§£æç½‘é¡µï¼Œ
  //    **å°† `username` è½¬æ¢ä¸º `channel_id`**ï¼Œç„¶åæ‰èƒ½ä½¿ç”¨ `/feeds/videos.xml`ã€‚
  //    ç”±äº Express ä»£ç†ä¸­æ²¡æœ‰ç°æˆçš„ `getDataByUsernameYoutubei` æˆ– `getDataByUsernameGoogle` å‡½æ•°ï¼Œ
  //    æˆ‘ä»¬å°†ä½¿ç”¨ **æœ€ç›´æ¥çš„æ¨¡ä»¿** æ–¹å¼ï¼Œ**å‡è®¾** å­˜åœ¨ä¸€ä¸ª `username` ç‰ˆæœ¬çš„ XML è®¢é˜…æº URLï¼ˆè™½ç„¶ YouTube å®˜æ–¹æ²¡æœ‰ï¼‰ã€‚

  const cacheKey = `user:${username}:${filterShorts}:${embed}`;
  const cached = cache.get(cacheKey);
  const now = Date.now();
  if (cached && now - cached.timestamp < CACHE_DURATION) {
    res.type("application/xml").send(cached.data);
    return;
  }

  try {
    // âš ï¸ è­¦å‘Šï¼šè¿™æ˜¯å¯¹ç¬¬ä¸€ä¸ªä»£ç å—åŠŸèƒ½çš„**ä¸å®Œæ•´**æ¨¡ä»¿ï¼Œ
    // å› ä¸º YouTube XML è®¢é˜…æºä¸ç›´æ¥æ”¯æŒ `@username`ã€‚
    // å®é™…å®ç°éœ€è¦ä¸€ä¸ªé¢å¤–çš„æ­¥éª¤æ¥æŸ¥æ‰¾ `channel_id`ã€‚
    // æˆ‘ä»¬åœ¨æ­¤å‡è®¾ä¸€ä¸ª **`/feeds/videos.xml?handle=`** çš„ç†æƒ³æƒ…å†µã€‚
    const feedUrl = `https://www.youtube.com/feeds/videos.xml?handle=${username}`;
    
    // **ç†æƒ³æƒ…å†µä¸‹ï¼Œè¿™é‡Œåº”è¯¥è°ƒç”¨ç¬¬ä¸€ä¸ªä»£ç å—ä¸­çš„ `callApi` é€»è¾‘æ¥è·å–æ•°æ®**
    // å¦‚ä¸‹æ‰€ç¤ºï¼š
    /*
    const data = await callApi({
        googleApi: getDataByUsernameGoogle,
        youtubeiApi: getDataByUsernameYoutubei,
        params: { username, embed, filterShorts, isJsonFeed: false },
    });
    // ç„¶åå°† data è½¬æ¢ä¸º XML
    */

    // --- ä¸´æ—¶æ›¿ä»£æ–¹æ¡ˆï¼šç›´æ¥å°è¯•è·å– feedUrl ---
    const feed = await fetchAndParseFeed(feedUrl);
    
    // å‡è®¾æˆ‘ä»¬èƒ½ä» feed ä¸­è·å–åˆ°çœŸæ­£çš„ channelId
    const inferredChannelId = feed.link?.["@_href"]?.match(/channel\/(.+)/)?.[1] || 'UNKNOWN_ID';

    // å‡è®¾ `feed` æ•°æ®ç»“æ„åŒ…å«æ‰€æœ‰è§†é¢‘ä¿¡æ¯ï¼Œä½†æˆ‘ä»¬**æ²¡æœ‰å®ç°** `filterShorts` é€»è¾‘ã€‚
    // **æ³¨æ„ï¼š** è¿™é‡Œçš„ `generateRssFromFeed` è¿˜æ²¡æœ‰å®ç° `filterShorts` è¿‡æ»¤çŸ­ç‰‡çš„åŠŸèƒ½ã€‚
    const xmlOutput = generateRssFromFeed(feed, inferredChannelId, feed.title);
    
    cache.set(cacheKey, { data: xmlOutput, timestamp: now });
    res.type("application/xml").send(xmlOutput);

  } catch (err) {
    console.error(`âŒ Fetch or parse error for user ${username}:`, err);
    // å¯¹äº @username çš„æƒ…å†µï¼Œ404 å¯èƒ½æ˜¯æ­£å¸¸çš„ï¼Œå› ä¸º YouTube ä¸æ”¯æŒæ­¤ URL ç»“æ„
    res.status(500).send(`âŒ Failed to fetch or parse feed for user ${username}. (Note: This function requires converting @username to channel_id, which is not implemented here.)`);
  }
});


const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`ğŸš€ Server running on port ${PORT}`));

import express from "express";
import fetch from "node-fetch";
import { create } from "xmlbuilder2";

const app = express();
const cache = new Map(); // ç®€å•ç¼“å­˜
const CACHE_DURATION = 60 * 60 * 1000; // 1å°æ—¶ç¼“å­˜ï¼ˆæ¯«ç§’ï¼‰

app.get("/", (req, res) => {
  res.send("âœ… YouTube RSS Proxy is running. Use /api/rss?channel_id=...");
});

app.get("/api/rss", async (req, res) => {
  const channelId = req.query.channel_id;
  if (!channelId) {
    return res.status(400).send("âŒ Missing channel_id parameter");
  }

  // æ£€æŸ¥ç¼“å­˜
  const cached = cache.get(channelId);
  const now = Date.now();
  if (cached && now - cached.timestamp < CACHE_DURATION) {
    console.log("ğŸ“¦ Using cached feed:", channelId);
    res.type("application/xml").send(cached.data);
    return;
  }

  try {
    console.log("ğŸŒ Fetching new feed from YouTube:", channelId);
    const feedUrl = `https://www.youtube.com/feeds/videos.xml?channel_id=${channelId}`;
    const response = await fetch(feedUrl);
    if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);

    const text = await response.text();
    const xml = create(text);
    const json = xml.end({ format: "object" });

    const rss = create({ version: "1.0", encoding: "UTF-8" })
      .ele("rss", { version: "2.0", "xmlns:media": "http://search.yahoo.com/mrss/" })
      .ele("channel")
      .ele("title").txt(json.feed.title).up()
      .ele("link").txt(`https://www.youtube.com/channel/${channelId}`).up()
      .ele("description").txt("Generated by YouTube RSS proxy on Render").up();

    (json.feed.entry || []).forEach((video) => {
      const videoId = video["yt:videoId"];
      const title = video.title;
      const link = video.link["@href"];
      const published = video.published;
      const author = video.author?.name || json.feed.author?.name || "YouTube Channel";
      const thumbnail = `https://i.ytimg.com/vi/${videoId}/hqdefault.jpg`;
      const description = video["media:group"]?.["media:description"] || "";

      const item = rss.ele("item");
      item.ele("title").txt(title).up();
      item.ele("link").txt(link).up();
      item.ele("author").txt(author).up();
      item.ele("pubDate").txt(new Date(published).toUTCString()).up();
      item.ele("description").dat(description).up();
      item.ele("media:thumbnail", { url: thumbnail }).up();
      item.up();
    });

    const xmlOutput = rss.end({ prettyPrint: true });

    // å†™å…¥ç¼“å­˜
    cache.set(channelId, { data: xmlOutput, timestamp: now });

    res.type("application/xml");
    res.send(xmlOutput);
  } catch (err) {
    console.error("âŒ Error generating feed:", err);
    res.status(500).send("âŒ Failed to fetch or parse feed");
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`ğŸš€ Server running on port ${PORT}`));
